#jvm8 GC的基本原理（下）

## 并发算法

### 硬件

#### 处理器与线程

**处理器**是硬件执行指令的单元，**线程**是单一顺序控制流，是软件执行的具体化，线程的状态可以是运行中、可运行或被阻塞。**调度器**通常是操作系统的组件，其功能就是在任意确定的时刻让线哪些线程在哪些处理器上执行。

**多处理器**是包含多个处理器的计算机，**片上多处理器（CMP）**是指单个集成电路芯片上集成多个处理器的技术，也称为**多核处理器**，**多线程**就是使用多个线程的软件，且每个线程可能在多个处理器上并发执行。**多程序**是指在单一处理器上执行多个进程或线程的软件。

#### 处理器与内存

**多处理器**与**集群计算、云计算或分布式计算**的区别在于前者每个处理器可以访问共享内存。常见的互联方式就是**总线**，我们可以简单的将内存访问操作看作是处理器与内存单元之间的消息通信，每次通信所需要的时间往往需要达到上百个时间周期。单个总线的原始速度非常快，但是多处理器同时发请求仍然会成为瓶颈。

因此为了提高整体的性能，内存往往会被分割为多个单元，同时处理器核内存之间的数据传输通常也都是共享高速缓存行而非单独的字或字节为单位。

如果内存单元和处理器之间相互独立，这样的系统架构可以被称为**对称多处理器（SMP）架构**，该架构中任意处理器访问任意内存单元的时间都是相同的。而其他访问时间不一致的架构被称之为**非一致内存访问（NUMA）架构**。同一系统啃根包含全局的SMP内存以及NUMA内存，每个处理器可能还拥有私有内存，但是共享内存与GC技术关系更大。

#### 内存

内存物理上可能跨越多个内存单元或处理器，但是在GC的角度来看，共享内存就是一块地址空间。由于内存时由多个可以并发访问的单元组成，所以无法在一个确定的时刻给出一个全局的描述，但是内存中的每个单元在每个时刻都是确定的。

#### 高速缓存

由于访问内存的速度非常的慢，现代架构体系都会在处理器和内存之间增加多层高速缓存，其中记录的就是处理器最近访问过的数据，进而降低访问内存的次数

告诉缓存和内存的数据交换是以行为单位，通常是32或64个字节。如果处理器访问一块数据已经在高速缓存中，那么就称为**高速缓存命中**，否则就是**高速缓存不命中**，此时会继续访问更高一级的缓存，直至访问到内存。

当某一级缓存出现不命中，且该级缓存无法容纳新的缓存行时，就需要一个**缓存置换**，被置换出来的被称为**受害者（victim）**，当缓存行写数据时使用的是**write-through**策略，即某一级缓存行更新时下一级缓存中的对应数据也会尽快更新。另一种策略是**write-back**，即被修改的行（脏行）得到换除之前其中的数据不会写入下一级缓存，除非是用指令显示flush。

缓存置换的策略很大程度上依赖于缓存的内部组织形式。**全相联**缓存允许内存中任意地址的数据放知道缓存的任意一行中，其置换也可以选择任意一行淘汰。另一个策略时**直接映射**缓存，即内存中某一地址的缓存只能放置到特定的行中，因而其置换策略也只能淘汰特定的缓存行。**k路组相联**是上述两个方案的这种，该策略即允许映射k个缓存行。

高速缓存各缓存之间的关系也需要注意，如果较低级别的缓存数据一定会在高级别的缓存中出现，则成为**严格包容关系**。如果同一数据最多只能出现在两级缓存中的一级，那么就称为**排他**。

#### 高速缓存一致性

由于高速缓存中的持有的数据在内存啃根时共享，同时每个缓存中的数据不可能同时得到更新，所以内存中的数据在不同的缓存行中的数据可能不一致。为了解决该问题，通常硬件会提供一个缓存一致性，其中经典的就是**MESI高速缓存一致性协议**。

在该协议中，缓存有四种状态

- **被修改（modified）**，该缓存行持有的数据唯一有效版本，其中的数据被修改过，但是没有写回内存。
- **独占（exlusive）**，该缓存持有数据的唯一有效版本，同时和内存一致。
- **共享（shared）**，其他缓存行也可能持有该数据的有效副本，同时副本中的数据均与内存保持一致。
- **无效（invalid）**，缓存行中不包含任何有效数据

只有当数据时m、e、s时处理器才可以读取该缓存行内的数据；

只有当缓存行的状态为m、e时，处理器才可以将数据写入该缓存行，同时写入置换要修改m；

如果处理器需要从i中读取数据，那么那么系统的后续行为将决定该缓存行在其他缓存中的状态：

1. 如果为m，那么其处理器必须将其写回缓存，并将其状态设置为s或i
2. 如果为e，那么就需要将它降级为s或i
3. 如果状态为s或i，那么就从直接加载货从内存中加载数据。
4. 如果要写入i的缓存行中，那么其他缓存行的最终状态都是i
5. 如果要写入s的缓存行中，必须先将其他的缓存行设置为i

MESI协议的目的就是确保缓存行一致。

#### 伪共享

当两个处理器同时访问并更新位于相同缓存行的不同数据，由于处理器在写之前必须将缓存行的状态设置为e，那么这两个处理器就会产生乒乓效应，不停的令对方无效，所以就导致两个处理器的高速缓存失效。

### 硬件内存一致性

**该一致性即不存在未完成的写操作**。比如两个处理器同时读取相同位置的内存，那么读取到的值是相同的；比如两个处理器对同一位置的内存同时发起写操作，那么其中一个一定先于另一个发生，且处理完后其他处理器读取到的值就是最后一次写入的值；比如如果一个处理器已经写入了最终值，该值未被其他处理器修改的情况下，任何读操作都不可能读取到其他值。

####重排序

所以针对内存中任何特定位置的写操作都是经过排序的，且在任意处理器看来，特定位置的值变化顺序是相同的。

但是对于程序中多个位置的写入（或读取），硬件系统不能保证总是按照程序的书写顺序来执行。也就是**程序顺序**不一定要于**内存顺序**完全一致。这么做的目的主要还是处于性能考虑，因为硬件都有一个**写缓冲区来保存完成的内存写入操作，写缓冲区本质上是一个<地址，数据>的队列**。

- 如果一个写入操作以及在队列中，后续又来一个新的写操作，就有可能两个写操作被合并成一个。所以这种情况下如果处理器在读取某一位置的值发现该位置存在未完成的写操作，要么通过硬件路径来读取，要么等待写缓冲区刷新完毕之后再读取。
- 另一个可能引起重排序大的可能是高速缓存不命中。一旦读取过程中发生高速缓存不命中，许多处理器会跳过该指令继续执行后续的指令。
- 还有一些重排序是编译器造成的。如果编译器认为两行代码交换位置（或者其他操作，比如合并）也没有实际影响，那么编译器就会执行优化，编译器会使得程序无论如何在单处理器下的执行顺序是不会变的（意味着多线程下可能会有问题）。

从开发者角度来看，重排序可能造成的潜在的一致性问题需要解决；从硬件角度来看，冲排序可能会大幅度提升硬件性能。

因此基于这样的矛盾，设计了内存屏障。

### 内存屏障

**内存屏障**是一种处理器操作，可以阻止处理器对某些内存访问进行重排序。**happens-before**则将这一概念更加规范化。使得较早的操作一定会在较晚的操作之前执行。

### 内存一致性模型

#### 严格一致性

即内存中的所有读、写、原子操作在整个系统的任意位置都是以相同的顺序发生。这样的一致性是绝大多数软件开发者以为的硬件所遵守的顺序，但是该模型很难高效的实现。

#### 顺序一致性

该模型中，全局顺序和处理上的单个顺序一致。

> 这个不是很好理解，举个例子：
>
> 比如两个进程P1, P2，初始状态a = b = 0。（下面错开代表实际指令发生时间，左边开始）
>
> **P1: 	write a = 1 									read b = 0**
>
> **P2: write b = 2			read a = 0**
>
> 这个顺序就是不符合顺序一致性的，因为能造成上述结果的逻辑顺序为 **read a = 0 -> read b = 0 -> write a = 1 -> write b = 2**，但是该逻辑顺序和局部时钟顺序不一致（read a = 0在write a = 1之前），也就不符合顺序一致性。
>
> 如果上面这个例子修改一下
>
> **P1: 	write a = 1 									read b = 2**
>
> **P2: write b = 2			read a = 0**
>
> 这个模型就符合顺序一致性了，因为他的逻辑顺序可以是 **write b = 2 -> read a = 0 -> write a = 1 -> read b = 2**该顺序符合局部时钟顺序，

#### 弱一致性

弱一致性通常是一些最终一致性的协议，你在写了数据之后，可能所有的读读到的都是旧数据，但是只要最终都能读到写之后的值即可。

##### 释放一致性

释放一致性就是像锁一样，我一定是获取了锁之后才做一些事情，也一定是释放了锁之后做别的事情，这个获取锁和释放锁的瞬间就是一个临界点，临界点两侧的操作不可以越过临界执行。

##### 因果一致性

就是对同一个变量的读写顺序是一致的。

### 硬件原语

#### compareAndSet、compareAndSwap

略

### 前进保障

当多个线程征用相同的数据时，确保整个系统能正常的继续执行下去非常重要，这样的特性被称为**前进保障**。保障级别从强到弱是**无等待**、**无障碍**、**无锁**。

## 并行GC算法

需要把所有的赋值器线程全部挂起知道回收结束的称为**万物静止式回收（STW）**

允许赋值器和回收器交替执行的称为**增量回收**。

允许赋值器线程和回收器线程同时执行的称为**并发回收**。

### 并行回收是否值得

如果我们需要引入并行算法，那么我们有一些我们需要考虑的问题：

- 是否又足够多的工作值得我们并行去做。
- 并行过程中引入的线程安全同步操作会增大回收的开销（比如原子操作、锁等）
- 有一些问题不利于并行收集。比如单链表结构（因为我永远都只有一个需要扫描的节点）

但是对于一个典型的Java应用来说，数据结构并不仅仅局限于单链表，同时大量的GC Roots都可以成为并发算法的起点，而且一个典型的Java程序往往可达对象的广度较大而非深度较深，所以并行回收的并行程度可以达到非常高，因此对整体性能的提升也非常可观。

### 负载均衡

上面说了有很多值得我们并行的工作，那么下一个问题就是如何合理分配处理器和并行任务，使得所有的处理器都尽可能的保持忙碌的状态。比如我有N个处理器，我们可以简单的把代回收空间平均N等分，但是这N个处理的工作都取决于各自所分到的区域的对象总量和存活对象总量，所以这样的简单负载均衡并不能使的所有的处理器都很好的处在工作状态。

所以我们需要一个动态负载均衡策略来确保工作分配的均衡。对于执行前可以预估工作量的任务，我们可以简单的实现，但是更多情况下，我们很难事先准确的预估到工作量并均衡划分，所以一般采用的方案是所需的工作划分比回收线程数量（处理器数量）更多的子任务，同时驱使线程一次获取一个任务来执行，如果某一个子任务执行时间较长，那么其他任务就会被其他线程执行。

但是也不是对任务的划分粒度越细越好（比如对每一个对象进行标记作为一个任务），因为工作线程申请任务是需要通过多线程同步的，所以如果太频繁的触发同步所引起的开销也是非常可观的。

### 并行算法分类

并行算法大致可以分为两类，**以处理器为中心的并行算法**和**以内存为中心的算法**。

以处理器为中心的算法中，线程获取的工作通常大小不等，且线程之间会存在工作窃取的行为，该策略不关注线程所处理对象的位置（所以该策略不够好，因为程序的局部性在单线程GC算法中都显得非常重要，如果不考虑对象的位置就会破坏程序的局部性）。

以内存为中心的算法更多的考虑局部性因素，此类算法通常针对对中连续内存块进行操作。因此线程就是从工作缓冲池中获取工作包，而该工作包的大小通常都是固定的。

而判断并行回收是否结束的策略其实就是任务池中的任务是否为空即可。

## 并发垃圾回收

在单线程的GC算法中，我们通过三色抽象来推断本次GC情况，但是在并发情况下，由于多核处理器的并发执行，是有可能会发生存活对象被错误地回收。

![image-20190728152151723](../../%E5%88%86%E4%BA%AB/jvm/img/jvm8-%E5%B9%B6%E5%8F%91%E5%9B%9E%E6%94%B6%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E4%B8%A2%E5%A4%B1.png)

上述两种情况出现的主要原因就是赋值器线程由于和GC线程并发执行，而并发执行的赋值器线程又破坏了灰色和白色对象之间的引用关系而导致的，所以其实满足如下两个条件就会造成存活对象丢失问题：

- 赋值器线程将某一个白色对象的引用写入到黑色对象之中
- 从灰色对象出发最终到达该白色对象的所有路径都被赋值器线程破坏。

因此为了确保并发情况下不会错误的回收存活对象，GC算法必须确保任意时刻上述两个条件都无法达成。因此只要黑色对象所引用的白色对象都能准确的被发现，那么这些对象将处于灰色保护状态。

###强三色不变式与弱三色不变式

为了确保垃圾回收器不会错误的回收存活对象，我们需要确保上面的条件不会出现，因此就有了这两个不变式

- **弱三色不变式**

  所有黑色对象应用的白色对象都处于灰色保护状态

- **强三色不变式**

  不存在从黑色对象指向白色对象的指针。

###赋值器颜色与新分配对象颜色

由于多线程环境下赋值器也极有可能存在多个，有可能存在有一个赋值器下的所有对象都已经被处理过了，而另一个还没有处理的情况。

所以可以通过给赋值器着色来判断分配对象时是否满足了强弱三色不变式，以此来判断是否回收器还需要对根进行扫描。

同样的，分配的对象也赋予适当的颜色，而赋值器的颜色会影响到分配对象的颜色，新分配对象的颜色会影响最终判断可达性时的回收及时性。所以如果统一分配为黑色或灰色，那么安全性可以得到保障，但是回收的及时性就难以保障。

### 基于增量更新的方案

为了解决对象丢失问题，有一种策略被称为基于增量更新策略。就是会把赋值器对已知存活对象集合的增量修改通知给回收器，进而产生了需要额外扫描的对象。

如果某一对象的引用被插入到追踪波面之后的黑色对象之中，增量更新方案会保守地将其当作存活对象。增量更新通过写屏障将所有写到黑色对象的白色对象都置为黑色。

###基于起始快照的解决方案

这个策略会保留回收起始阶段所有存活对象的快照，当赋值器删除波面之前的指向白色对象的指针时，会通过写屏障，将这一行为通知回收器。回收器会保守的将其当作非白色对象。

该方案使用写屏障来拦截赋值器从灰色或白色对象中删除灰色或白色对象的指针。同时起始快照方案只允许黑色赋值器的存在。

### 并发写屏障的实现 — 用卡表(Card Table)来实现记忆集(Memory Set)

卡表除了可以用于分代回收器中记录分代间指针，也可以用于并发回收器中。对于需要记录到卡表中的灰色对象，写屏障会将其所处的卡在卡表中对应的字节打上脏标记。与此同时回收器也会并发的扫描卡表，找出灰色对象并对其进行追踪，最后清除脏标记。

#### 单级卡表

单级卡表是最简单的卡表实现方式，该卡表可以有三种状态：脏、清理中、已清理。赋值器可以通过简单的指令将卡表标记为脏，回收器线程发现脏卡时，现谁为处理中，然后寻找回收相关指针，最后再确定新状态。

####两级卡表

大部分卡其实都是处于已清理的状态，因此两级卡表可以提升回收器在卡表中寻找脏卡的效率。一个二级卡表中，每个条亩对应2^n^个卡表。

### 考虑的问题

不论是增量回收器还是并发回收器，目的都是最大限度的缩短赋值器可以感知到的回收停顿时间。但是引入并发就必须要求并发赋值和回收之间需要某种程度的通信和同步，具体表现就是各种屏障。

浮动垃圾也是并发算法需要考虑的问题，允许浮动垃圾可以加速回收周期，但是也会带来额外的内存压力（浮动垃圾就是有些垃圾在本次回收中无法回收）

####混合分代/回收器

该方案即大多采用的使用传统分代策略来管理年轻代，年老带使用并发回收器来管理。因为年轻代回收器短，且大部分对象都能得到回收；老年代修改频率低得多，对写屏障的调用频率也很低。

## 并发标记-清除算法

标记清扫时最简单的一类并发回收器，因为在回收器不会修改指针域，所以赋值器可以自由的从堆中加载指针。非移动式回收器天然不需要读屏障，而对于堆的操作其实读操作往往更频繁一些。

### 初始化

并发回收器通常不会等到赋值器内存完全耗尽才开始执行。回收器启动后首先清空工作列表，扫描赋值器根建立最初的工作列表（扫描赋值器根的过程往往需要把所有赋值器线程都挂起）。由于该算法需要STW过程，因此该算法属于主体并发模式。根据扫描过程遍历到的灰色根对象构成了后续扫描过程的回收波面。

在初始根扫描过程中结束之后，赋值器可以继续恢复执行，同时进入并发标记阶段，其所使用的写屏障类型将决定赋值器本身的颜色是黑色还是灰色。

### 并发分配

由于新对象的分配必须也要遵循一定的颜色，

赋值器为黑色，如果要满足强三色不变式，那么所有对象都是黑色。如果要满足弱三色不变式，那么分配器必须判断新分配对象是否为灰色对象可达，由于分配器通常很难判断一个新对象是否是灰色对象可达，所以通常弱三色不变式对新对象的分配也是黑色。**所以如果赋值器为黑色，通常新分配的对象也都是黑色。**

灰色赋值器的实现在分配对象时则存在多种着色策略。

- 并发标记阶段对象都为黑色，其他阶段都为白色
- 根据分配对象指针域的初始值。比如这个对象分配是所需要的参数都不是白色，那么这个对象大概率也不会是白色等。
- 已经请扫过的区域新分配为白色，没有请扫过的区域为黑色。

如果分配的白色偏多，就需要回收器对该白色对象链进行追踪；如果分配的黑色较多，那么其中的垃圾只能等到下一次回收时才能清除。因此也有提出一种折中方案，新分配的对象使用第四种颜色==黄色==，清扫器将黄色对象当作白色（碰到直接回收），标记器将黄色对象当作黑色（碰到直接改为黑色，不用进行扫描）

### 初始化结束

如果只允许黑色赋值器，那么这个结束过程是一相对简单的过程，只要工作列表中不包含灰色对象即可。

如果允许灰色赋值器的存在，那么赋值器可能在并发阶段又引入了白色指针，因此在回收之前，回收器必须重新扫描灰色赋值器的根。

### 标记过程与清扫过程并发

上面描述的是标记阶段和赋值器之间的并发，但是实际上标记过程与清扫过程也是可以并发的。

- 将所有白色节点着为紫色
- 将所有黑色节点着为白色或灰色
- 为所有赋值器根着色
- 启动标记器与清扫器

> 算法略。通过紫色对象等来实现。

### 即时标记

以上的算法均假定标记阶段是需要挂起所有的赋值器线程以扫描所有的根对象，扫描完之后赋值器就不包含白色对象，之后赋值器可以以黑色或灰色继续运行，但是这样的STW方式降低了并发度。

所以有另一种策略就是独立的对每个赋值器的根进行采样，此过程可以与其他赋值器线程并罚执行，但是这一策略会引入额外的复杂度，同一时刻某些赋值器线程在灰色状态下执行，其他赋值器线程则在黑色状态下执行，这样算法的判定结果会有一些问题。

所以可以通过一个回收器和赋值器之间的软握手机制来实现后者根的扫描。在这个过程中，需要逐个、异步地将赋值器线程在某个合适的位置挂起，然后扫描当前状态，然后再恢复执行。

但是为即时标记过程涉及正确的赋值器 — 回收器的同步机制是一个非常复杂的问题。对于需要STW的算法而言，他们仅需要扫描栈上所有对象并使用黑色赋值器+删除屏障。

###Doligez-Leroy-Gonthier回收器

略

### 需要考虑的问题

并发标记—清除中碰到的问题其实是所有并发式回收器的共性问题，我们应当首先考虑是否应当使用并发式回收器，以及引入在设计、实现、调试测试等各方面的复杂度是否有必要。

对于绝大多数程序而言，分代回收器以及可以满足毫秒级别的停顿时间，但是在最差情况下，其总回收时间依然会陡增，并且这取决于对空间大小以及兑现存活总量等因素。设计良好的实时回收是有必要的，但是赋值器、回收器都需要承担额外的开销。

##并发复制、并发整理

> 考虑的问题和上面一致，这一章节原书全部都是算法和各类回收器的实现原理，因此我们略

##并发引用计数

单线程的引用计数算法遵循的是当有一个引用时引用+1，当丢失一个引用时引用引用-1。但是在并发条件下，即便引用数原子的加一减一也不能确保计数的正确性。

比如这个例子：

```java
// 线程A给数组o中第i个位置的元素替换为x
write(o, i, x) {
  addReference(x);
  old <- o[i];
  deleteReference(old);
  o[i] <- x;
}

// 线程B给数组o中第i个位置的元素替换为x
write(o, i, y) {
  addReference(y);
  old <- o[i];
  deleteReference(old);
  o[i] <- y;
}
```

可以看到如果两个线程并发的修改数组中的某一个位置，我们按照单线程的处理方式，新对象引用+1，然后老对象引用-1，即便计数是并发安全的，但是也不能确保最终对象计数的正确性。

发生上面这个问题的原因是引用计数操作没有与指针更新操作保持同步，两个线程更新的都是方法中的局部变量。

所以并发引用计数算法设计难点并不是如何原子的、高效的更新计数，而是如何确保计数变更操作与指针的读写同步。

### 加锁确保指针与计数同步

> 算法略。具体做法就是在操作数组/对象前把这个对象锁起来

在并发编程的领域，一个很诱人的想法就是通过原子操作来开发一种无锁化算法，但是在打一内存地址的原子操作不足以满足算法的安全性，所以在并发引用计数算法下无锁化Read或Write都是可以的，**但是同时无锁化两个阶段的算法是不存在的**。

### compareAndSwap2

该原语即可以原子化更新内存中任意两个（不相邻）的内存字。**（由于硬件实现非常复杂，目前无商业级别处理器支持该原语）**。该原语即事务化内存管理，其实就是同时原子的更新2个（或n个）内存字。普通的compareAndSet只能原子更新一个内存字。

因此如果想要通过无锁化算法，必须提升compareAndSet原语的范围才有可能来实现，但是该原语目前仅在实验室级别存在。

**简单总结一下就是目前硬件级别并发引用计数不加锁就做不到。**

### 缓冲引用计数

由于引用计数要么要使用锁（很大程度上会降低性能，因为是每一个对象的读写都要加锁，这个开销非常恐怖）。

所以就使用缓冲引用计数策略。该策略在赋值器变更每个指针更新操作时，将新旧引用写入日志中；另外在新起一个引用计数线程来处理日志并修正对象的引用计数数值，由于仅仅使用了一个引用计数线程，所以天然就保证了更新的原子化；但是依然没有解决指针和引用计数的一致性问题。

### 并发情况下的环状垃圾

由于环状垃圾的解决算法通常是实验删除法，但是并发情况下会有三个额外的问题：

- 在检测环状垃圾的过程中，由于赋值器会并发修改对象图，所以回收器很难再次扫描同一个字图
- 实验删除可能会导致字图与存活对象图失去联系
- 引用计数可能会过时

### 堆快照

为了解决在并发情况下的这些问题，通常的做法就是扫描整个堆并进行快照，然后赋值器线程在并发运行时对修改过的对象进行脏标记，等到快照扫描结束之后再对标记为脏的对象处理即可。

### 滑动视图引用计数

为了获取堆快照，做法就是通过挂起所有的赋值器线程。滑动视图算法就是为了放宽这一限制，从而达到一次只挂起一个赋值器线程的即时回收的要求，不同对象的指针域将在不同的时刻得到记录，也会在不同的时间点交给回收器线程。

该算法不需要锁也不需要任何原子操作指令，但是赋值器线程需要与回收器线程进行4次握手。

在该算法的基础上，还有一些进一步的算法，比如朴素引用计数、分代回收器中年老带的管理、面向年龄的回收器等。

#### 面向年龄

该算法也是分为年轻代和老年代，于传统的分代回收器不同（年轻代回收的时候仅回收年轻代），该算法的年轻代和老年代同时回收，因此不需要记录分代间指针。管理年轻代用年轻对象朝生夕死的特点、管理老年代用老年代死亡率低、变更率低的特点。

### 考虑的问题

并发环境下，引用计数算法首要面临的问题就是如何正确的维护对象的引用计数。**最简单的策略就是加锁。**

如果不用加锁的方式，就必须要考虑指针写入与引用计数变更操作的序列化关系，

- 延迟引用计数，但是该策略会导致垃圾对象回收延迟，同时会将回收任务交给单独的回收线程来处理。
- 缓冲引用计数，通过将对对象的操作记录到日志的做法，周期性的将日志传递给回收器。
- 合并引用计数，在上面两个计数基础上进行扩展，通过获得修改之前的快照，减少冗余的应用技术；同时通过快照也可以在试验删除的过程中确保追踪器每次追踪的都是同一个子图。

## 实时垃圾回收

在垃圾回收的算法当中，不论是使用增量算法、惰性算法还是并发算法，其目的都是为了减少赋值器能够感知到的回收停顿时间。并发、增量回收算法都是针对在一些延迟十分敏感的应用而设计的。而真正的实时回收就是能够非常精确的控制有垃圾回收所导致的赋值器中断。

###实时系统

实时系统，就是给定一个任务必须要在给定的时间窗口内完成相应，如果无法完成相应就可能会导致服务质量下降或系统性灾难（比如请求长时间没有响应、定时点火失败导致机器故障等）。

####软实时系统

此类型的实时系统就是能忍受响应时间超限，虽然代价是服务质量下降，但是偶尔的超时是可以接受的。比如我们的互联网应用大部分都是软实时系统，只要失败率控制在一个可以接受的范围内即可

####硬实时系统

该种类型的系统不允许任何超时，多见于工程控制领域。比如一些嵌入式处理器等。

因此对于上述两种实时系统，软实时可以接受万物静止回收，但是硬实时系统很难接受这样不可控制的停顿所造成的影响（这也是一些嵌入式系统多半还是c/c++、汇编等语言为主）

### 实时回收的调度

何时触发垃圾回收以及如何触发，是回收器影响赋值器执行的主要方面。对于万物静止式的回收往往在内存快要耗尽的时候；增量回收器则会在每次访问堆的时候通过读写屏障来承担一定的回收工作。并发回收器则会在赋值器工作的同时并发执行回收工作。

目前有两种主要的调度方式：

- **基于工作的调度策略**，该策略会把回收工作分摊到赋值器的每个工作单元中。
- **基于间隙的调度**，该策略会把实施任务的调度间隙来执行回收工作。如果实施任务发生的频率不高或间隙性的发生，那么当中其实有很长的空闲时间，因此只要另回收线程的优先级低于实时任务优先级便可以简单是一个基于间隙的调度。
- **基于时间的调度**，该策略会为回收器保留预定的独占式运行时间，在此期间赋值器线程将处于挂起状态，该策略能够满足预定的最小赋值器使用率的要求。

### 三种调度的算法

略。省略了了不同调度策略下不同的算法，以及各个算法的优点和缺点。

> 实时回收是目前GC领域研究的热点，因为之前的算法好多都是七十八十年代的成果，而实时算法基本都是00年之后的成果。