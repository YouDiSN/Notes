#REDIS源码24-分布式锁

分布式锁严格来不能算Redis的源码，Redis本身并没有直接提供分布式锁的功能，只不过在实际应用过程中可以通过灵活的使用Redis提供的功能来实现。

##简单场景

一般来说如果简单的来使用Redis的分布式锁，直接使用setnx就可以了，如果执行完毕在调用del来删除这个key就可以了。不过这是在最最简单的场景下，既然是分布式场景，万一获取锁的机器在del之前就挂了，那么这样的实现方式会导致一个死锁的问题。

##超时时间

那么一般解决死锁的方式第一个想到的就是超时时间，比如设置5s超时时间，这样就可以在一定时间之后确保整个系统能够继续运行下去。但是这样的实现也有问题，老版本的Redis里，setnx和expire是两个指令，既然是两个指令就有可能setnx完了机器挂了，连expire都没机会执行。不过现在Redis已经支持了setnx+expire作为同一个命令一起执行。

## 更进一步

设置了超时时间也有可能不安全，比如5s过时，上一个持有锁的线程执行了5s并且还会继续执行，那么锁被超时释放了也会导致有第二个线程能获取到锁。

因此就可以采用设置一个owner线程ID，并且这个线程如果在执行还要定时去续租。不过这样的实现就会很复杂。

## RedLock

上面都是使用锁的机器发生异常会导致分布式锁的失效，还有一种情况就是Redis Server挂了，也会导致一场。比如Redis一主两从，主节点刚获取锁就立即挂了，两个从节点还没有从主节点获取到锁，也会导致一场。

因此有一个RedLock的算法，大致就是有多个Redis实例（没有主从关系），如果我要获取锁就需要在大多数的Redis实例中获取成功，释放锁的时候也需要在大多数的机器中释放成功。

这里RedLock还需要考虑不同机器之间的时钟不同步、失败重试机制等。有兴趣可以再研究。目前陆金所内部使用的Redis分布式锁主要是依靠Lua脚本来实现的，Lua脚本实现的原因就是Lua脚本可以原子的执行多个指令。